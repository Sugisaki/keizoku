import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart'; // Add this
import 'package:intl/intl.dart';
import 'package:flutter_calendar_app/providers/calendar_provider.dart';
import 'package:flutter_calendar_app/repositories/records_repository.dart';
import 'package:flutter_calendar_app/repositories/settings_repository.dart';
import 'package:flutter_calendar_app/repositories/items_repository.dart';
import 'package:flutter_calendar_app/repositories/language_repository.dart';
import 'package:flutter_calendar_app/repositories/local/local_records_repository.dart';
import 'package:flutter_calendar_app/repositories/firestore/firestore_records_repository.dart';
import 'package:flutter_calendar_app/models/calendar_settings.dart';
import 'package:flutter_calendar_app/models/calendar_item.dart';
import 'package:flutter_calendar_app/models/language_settings.dart';
import 'package:flutter_calendar_app/models/calendar_records.dart'; // Add this line

import 'package:firebase_auth/firebase_auth.dart';

import 'dart:io';
import 'dart:convert';

import 'records_saving_test.mocks.dart'; // Add this

// Mock PathProviderPlatform
class MockPathProviderPlatform extends PathProviderPlatform with Mock {
  @override
  Future<String?> getApplicationDocumentsPath() async {
    return Directory.current.path; // Use current directory for testing
  }
}

// Mock Repositories
class MockSettingsRepository extends Mock implements SettingsRepository {
  @override
  Future<CalendarSettings> loadSettings() async => CalendarSettings();
  @override
  Future<void> saveSettings(CalendarSettings settings) async {}
}

class MockItemsRepository extends Mock implements ItemsRepository {
  @override
  Future<List<CalendarItem>> loadItems() async => [];
  @override
  Future<void> saveItems(List<CalendarItem> items) async {}
}

class MockLanguageRepository extends Mock implements LanguageRepository {
  @override
  Future<LanguageSettings> loadLanguageSettings() async => const LanguageSettings();
  @override
  Future<void> saveLanguageSettings(LanguageSettings settings) async {}
}

@GenerateMocks([
  FirestoreRecordsRepository,
  FirebaseAuth,
  User,
])
void main() {
  group('Records Saving Test', () {
    late LocalRecordsRepository localRecordsRepository;
    late CalendarProvider calendarProvider;
    late String testFilePath;

    setUp(() async {
      // Initialize mock path provider
      PathProviderPlatform.instance = MockPathProviderPlatform();

      localRecordsRepository = LocalRecordsRepository();
      testFilePath = '${Directory.current.path}/calendar_records.json';

      // Ensure the test file is clean before each test
      final file = File(testFilePath);
      print('Deleting file: ${file.path}');
      print('File exists before delete: ${await file.exists()}');
      if (await file.exists()) {
        await file.delete();
      }

      // Initialize mock repositories and firebase auth
      final mockSettingsRepository = MockSettingsRepository();
      final mockItemsRepository = MockItemsRepository();
      final mockLanguageRepository = MockLanguageRepository();
      final mockFirestoreRecordsRepository = MockFirestoreRecordsRepository();
      final mockFirebaseAuth = MockFirebaseAuth();

      // Mock FirebaseAuth.currentUser to return a MockUser
      // MockUser is generated by build_runner, so we need to import records_saving_test.mocks.dart
      final mockUser = MockUser(); // Use generated MockUser
      when(mockFirebaseAuth.currentUser).thenReturn(mockUser);
      when(mockUser.uid).thenReturn('test_uid'); // Assuming MockUser has a uid getter

      // Mock FirestoreRecordsRepository.loadRecordsWithTimestamp
      when(mockFirestoreRecordsRepository.loadRecordsWithTimestamp())
          .thenAnswer((_) async => (records: CalendarRecords(recordsMap: {}), lastUpdated: null));

      calendarProvider = CalendarProvider(
        settingsRepository: mockSettingsRepository,
        localRecordsRepository: localRecordsRepository,
        firestoreRecordsRepository: mockFirestoreRecordsRepository,
        itemsRepository: mockItemsRepository,
        languageRepository: mockLanguageRepository,
        firebaseAuth: mockFirebaseAuth,
      );
      await calendarProvider.loadData(); // Load initial data (should be empty)
    });

    tearDown(() async {
      // Clean up the test file after each test
      final file = File(testFilePath);
      if (await file.exists()) {
        await file.delete();
      }
    });

    test("should save a today's record with specific time and item ID without milliseconds", () async {
      final testDateTime = DateTime.utc(2023, 5, 21, 13, 50, 3); // UTCで固定の日時を使用
      final testItemId = 1;

      // Add the record
      await calendarProvider.updateRecordsForToday(testDateTime, [testItemId], []);
      // Reload data from the provider to ensure it reads the saved data
      await calendarProvider.loadData();

      // Verify the records in the provider
      final records = calendarProvider.records.recordsWithTime;
      expect(records.length, 1);
      expect(records.first.dateTime.year, testDateTime.year);
      expect(records.first.dateTime.month, testDateTime.month);
      expect(records.first.dateTime.day, testDateTime.day);
      expect(records.first.dateTime.hour, testDateTime.hour);
      expect(records.first.dateTime.minute, testDateTime.minute);
      expect(records.first.dateTime.second, testDateTime.second);
      expect(records.first.itemId, testItemId);
    });

    test("should save a yesterday's record with specific time and item ID with 999 milliseconds", () async {
      final testDateTime = DateTime.utc(2023, 5, 20, 13, 50, 3, 999); // UTCで固定の日時を使用
      final testItemId = 1;

      // Add the record
      await calendarProvider.updateRecordsForToday(testDateTime, [testItemId], []);

      // Reload data from the provider to ensure it reads the saved data
      await calendarProvider.loadData();

      // Verify the records in the provider
      final records = calendarProvider.records.recordsWithTime;
      expect(records.length, 1);
      expect(records.first.dateTime.year, testDateTime.year);
      expect(records.first.dateTime.month, testDateTime.month);
      expect(records.first.dateTime.day, testDateTime.day);
      expect(records.first.dateTime.hour, testDateTime.hour);
      expect(records.first.dateTime.minute, testDateTime.minute);
      expect(records.first.dateTime.second, testDateTime.second);
      // ミリ秒は保存されないため、検証しない
      expect(records.first.itemId, testItemId);
    });
  });
}
